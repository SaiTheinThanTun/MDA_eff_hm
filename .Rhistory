# % set(gca,'FontSize',14,'XTick',xticktimes,'XTickLabel',xticklabels)
# % ylim([0.5 100])
# % xlim([0 48])
# % xlabel('Time in days')
class(ej)
class(ej * v[,m-1])
v[,3]=ej*v[2]
v[,3]=ej*v[,2]
v[,3]=ej%*%v[,2]
# % Names of variables
# % COMP = (1)  ;(ABSORB, DEFDOSE)
# % COMP = (2)  ;(CENTRAL)
# % COMP = (3)  ;(TRANSIT 1)
# % COMP = (4)  ;(TRANSIT 2)
# % COMP = (5)  ;(TRANSIT 3)
# % COMP = (6)  ;(TRANSIT 4)
# % COMP = (7)  ;(TRANSIT 5)
# % COMP = (8)  ;(TRANSIT 6)
# % COMP = (9)  ;(TRANSIT 7)
library(Matrix)
library(pracma)
npeople = 1
dosing = 40
# % flag = pregnant
# % para is initial parasitaemia
# % scale is the natural log of patient parasitaemia
# %dimension of system
n=9
# %time steps
# %size of time step
da=1 #.003
days=10
# %maximum age in hours for 10 days period
maxa=days*24
# %no. of timesteps
asteps=maxa/da
nasteps=asteps
# %no. of timesteps in a day
oneday=24*(1/da)
# % dosing times,
# % calculating index for mda
dt=da
mda1=(24/dt)
mda2=(48/dt)
mda3=(72/dt)
# %%PK piperaquine parameters
ACL = 0.75
AV = 1
M_WE = 48.5
# THETA=[78.0;129;0.982;1;0.58;-0.375;0.278];
# % 1.CL/F L/h
# % 2.V2/F  L
# % 3. MT
# % 4. F1
# % 5. w
# % 6. F1 Flag
# % 7.F1 para
Theta_CL_F <- 78.0
Theta_V2_F <- 129
Theta_MT <- 0.982
Theta_F1 <- 1
Theta_w <- 0.58
Theta_F1_flag <- -0.375
Theta_F1_para <- 0.278
FLAG=1
# OMEGA=[1 ; 0.0162; 1; 0.088; 1; 0.23 ];
Omega_CL <- 1
Omega_V2 <- .0162
Omega_MT <-1
Omega_F1 <- .088
Omega_W <- 1
Omega_MTT_IOV <- 0.23
WT=48.5
PARA=3.98
# TVCL = THETA(1)*(WT/M_WE)^ACL;
# TVV2 = THETA(2)*(WT/M_WE)^AV;
# TVMT = THETA(3);
# TVF1 = THETA(4)*(1+THETA(6)*FLAG)*(1+THETA(7)*(PARA-3.98));
TVCL = Theta_CL_F*(WT/M_WE)^ACL
TVV2 = Theta_V2_F*(WT/M_WE)^AV
TVMT = Theta_MT
TVF1 = Theta_F1*(1+Theta_F1_flag*FLAG)*(1+Theta_F1_para*(PARA-3.98))
# % initialize solution matrix - rows are people , columns are timesteps
vv=matrix(0,npeople,asteps+1)
# tic
# % run system for each person
# for jj = 1: npeople
for(jj in 1:npeople){
# % assign parameters to each person - mean estimate times randomly
# % distributed number with mean 0 and variance omega
CL = TVCL
V2 = TVV2
MT = TVMT
# %     F10 = TVF1;  % CHECK THIS
F10 = 1
F1 = F10
NN = 7
KTR = (NN+1)/MT
K13 = KTR
K34 = KTR
K45 = KTR
K56 = KTR
K67 = KTR
K78 = KTR
K89 = KTR
K92 = KTR
K20 = CL/V2
S2 = V2/1000
VD = V2
W= Theta_w #THETA(5);
# %set up V = solution matrix - rows is number of compartments or variable,
# %colums is number timesteps
v=matrix(0,n,asteps+1)
# %initialize jacobian like matrix
J=matrix(0,n,n)
# for m=2:asteps+1
for(m in 2:(asteps+1))
{
# %  state transition matrix
diag(J) <- c(-K13,-K20,-K34,-K45,-K56,-K67,-K78,-K89,-K92)
J[2,9] <- K92
J[3,1] <- K13
J[4,3] <- K34
J[5,4] <- K45
J[6,5] <- K56
J[7,6] <- K67
J[8,7] <- K78
J[9,8] <- K89
# J=[
#   -K13 0 0 0 0 0 0 0 0;
#   0 -K20 0 0 0 0 0 0 K92;
#   K13 0 -K34 0 0 0 0 0 0;
#   0 0 K34 -K45 0 0 0 0 0;
#   0 0 0 K45 -K56 0 0 0 0;
#   0 0 0 0 K56 -K67 0 0 0;
#   0 0 0 0 0 K67 -K78 0 0;
#   0 0 0 0 0 0 K78 -K89 0;
#   0 0 0 0 0 0 0 K89 -K92;
#   ];
# % calc new V
ej=expm(J*dt)
v[,m]= ej %*% v[,m-1]
#v[,m]= as.matrix(ej %*% v[,m-1])
# % assign different dosing absorption rates per dose.
if (m==mda1){
v[1,m]=dosing*F1+v[1,m]
}
if (m==mda2){
v[1,m]=dosing*F1+v[1,m]
}
if (m==mda3){
v[1,m]=dosing*F1+v[1,m]
}
}
# % keep solution for compartment 2 for each individual
vv[jj,]=v[2,]
xticktimes=seq(from=24,by=24,to=maxa)
xticklabels=1:10
v[2,ncol(v)]=NaN
# %     patch((0:da:maxa),v(2,:),'black','EdgeColor','black','FaceAlpha',0.2);
# %     set(gca,'FontSize',14,'XTick',xticktimes,'XTickLabel',1:1:days)
# %     hold on
}
#end
#toc
# %millitres of blood in adult
bl=4.5*1000
# %nanograms in miligrams
ng=1*10^6
mvv=vv[1,]
semilogy(seq(0,maxa, by=da), mvv*ng/bl, type='l', xlim=c(0,71), ylim=c(0.5,10000), xlab="Time in hours")
# figure(2)
# semilogy((0:da:maxa),mvv*ng/bl,'k','LineWidth',3)
# set(gca,'FontSize',14,'XTick',xticktimes,'XTickLabel',xticklabels)
# ylim([0.5 10000])
# xlim([0 72])
# xlabel('Time in days')
# hold on
# % figure(3)
# % semilogy((0:da:maxa),mvv,'k','LineWidth',3)
# % set(gca,'FontSize',14,'XTick',xticktimes,'XTickLabel',xticklabels)
# % ylim([0.5 100])
# % xlim([0 48])
# % xlabel('Time in days')
1/24
shiny::runApp('OneDrive/MORU/Projects/TCE_MDA effect/MDA_eff copy')
20/(1+.7)
16/(1+.7)
shiny::runApp('OneDrive/MORU/Projects/TCE_MDA effect/MDA_eff copy')
runApp('OneDrive/MORU/Projects/TCE_MDA effect/published version/v8_booster')
testfor2j <- rep(0:100,81)
testfor2i <- rep(0:80,each=101)
testfor2 <- cbind(testfor2j,testfor2i)
testfor2
testfor2j <- rep(0:80,81)
testfor2i <- rep(0:80,each=81)
testfor2 <- cbind(testfor2j,testfor2i)
tail(testfor2)
testfor2j <- rep(0:80,101)
testfor2i <- rep(0:100,each=81)
testfor2 <- cbind(testfor2j,testfor2i)
tail(testfor2)
for(i in 1:101){
for(j in 1:81){
bh_max1 <- testfor2[((i-1)*81)+j,1]
cmda_1 <- cmda_2 <- testfor2[((i-1)*81)+j,2]}}
cmda_1
cmda_2
bh_max1
#for loop for changing homogeneity between the two villages
#MDA_eff_hm
#X: HBR in village 2: [0-80];
#Y: MDA coverage in both villages [0-100] %;
#Z: changing homogeneity; HBR in village 1 is fixed at 16
#20190402
#see #scenario tag for things to change in each scenario
#x axis variable: homogen, [0 to 100] %
#y axis variable: cmda_2, [0 to 80] %, coverage of MDA in second village
setwd("~/OneDrive/MORU/Projects/TCE_MDA effect/MDA_eff_hm/") #mac
library(deSolve)
library(shiny)
library(TSA)
library(Rcpp)
library(stringr)
library(lattice)
sourceCpp("functions/modGMS_seas.cpp")
source("functions/no longer app.R")
timeVector <- read.csv('parameters/times.csv') #to figure out when the MDA finishes
#scenario
##initialize input and output storage####
testfor2j <- rep(0:80,101)
testfor2i <- rep(0:100,each=81)
testfor2 <- cbind(testfor2j,testfor2i)
# colnames(testfor2) <- c('homogen','cmda_2')
colnames(testfor2) <- NULL
#scenario
####for template####
# for(i in 1:81){
#   for(j in 1:101){
#     homogen <- testfor2[((i-1)*101)+j,1]
#     cmda_2 <- testfor2[((i-1)*101)+j,2]
#     ###other codes for running the model
#     result[[((i-1)*101)+j]] <- successMDA
#   }
# }
####non-reactive parameters####
####interventions####
EDATon = TRUE
ITNon = TRUE
IRSon = FALSE
MDAon = TRUE
primon = TRUE #FALSE
MSATon = TRUE
VACon = FALSE
####non-reactive functions####
#got from the "parameters" folder #scenario
homoLoop <- seq(0, by=10, to=100)
for(loop in 1:length(homoLoop)){
result <- list()
API <- 2.5
eta <- 30
covEDAT0 <- 25
covITN0 <- 70
effITN <- 30
covIRS0 <- 0
effIRS <- 15
muC <- 1
muA <- 1
muU <- 1
percfail2018 <- 5
percfail2019 <- 15
percfail2020 <- 30
bh_max0 <- 16
#bh_max1 <- 16 #scenario
rhoa <- 55
rhou <- 17
EDATscale <- 1
covEDATi <- 70
ITNscale <- 1
covITNi <- 90
IRSscale <- 1
covIRSi <- 90
lossd <- 30
dm0 <- 3
dm1 <- 3
#cmda_1 <- cmda_1Loop[loop]#80 #90
#cmda_2 <- 50 #scenario
homogen <- homoLoop[loop] #0 #scenario
tm_1 <- 9
tm_2 <- 9
p1v <- 0.5
effv_1 <- 75
effv_2 <- 80
vh <- 90
MSATscale <- 1
covMSATi <- 90
MSATsensC <- 99
MSATsensA <- 87
MSATsensU <- 44
#non-reactive parameters
# define the number of weeks to run the model
dt<-1/12
startyear<-2007
stopyear<-2023
maxt<-stopyear-startyear
times <- seq(0, maxt, by = dt)
tsteps<-length(times)
# initial prevalence
initprevR <- (0.001*API)
#ParLabel <- read.table('functions/ParLabel.csv', sep=",", as.is=TRUE)
# scenario_0<-c(EDATon = 0,
#               ITNon = 0,
#               IRSon = 0,
#               MDAon = 0,
#               primon = 0,
#               MSATon = 0,
#               VACon = 0)
####for loop#####
for(i in 1:101){
for(j in 1:81){
bh_max1 <- testfor2[((i-1)*81)+j,1]
cmda_1 <- cmda_2 <- testfor2[((i-1)*81)+j,2]
###other codes for running the model
scenario_iR<-(c(EDATon = EDATon,
ITNon = ITNon,
IRSon = IRSon,
MDAon = MDAon,
primon = primon,
MSATon = MSATon,
VACon = as.numeric(VACon)))
parametersR <- (c(
bh_max0 = bh_max0,                 # bites per human per night
bh_max1 = bh_max1,
eta = eta,
covEDAT0 = covEDAT0,
covITN0 = covITN0,
effITN = effITN,
covIRS0 = covIRS0,
effIRS = effIRS,
muC = muC,
muA = muA,
muU = muU,
percfail2018 = percfail2018,
percfail2019 = percfail2019,
percfail2020 = percfail2020,
EDATscale = EDATscale,
covEDATi = covEDATi,
ITNscale = ITNscale,
covITNi = covITNi,
IRSscale = IRSscale,
covIRSi = covIRSi,
cmda_1 = cmda_1,
cmda_2 = cmda_2,
tm_1 = tm_1,          # timing of 1st round [2018 to 2021 - 1 month steps]
tm_2 = tm_2,          # timing of 2nd round [2018+(1/12) to 2021 - 1 month steps]
dm0 = dm0,
dm1 = dm1,
lossd = lossd,
MSATscale = MSATscale,
covMSATi = covMSATi,
MSATsensC = MSATsensC,
MSATsensA = MSATsensA,
MSATsensU = MSATsensU,
effv_1 = effv_1,
effv_2 = effv_2,
vh = vh,
homogen = homogen,
p1v = p1v,
rhoa=rhoa,
rhou=rhou
))
#GMSout0R <- (runGMS(initprevR, scenario_0,parametersR))
GMSoutiR <- (runGMS(initprevR, scenario_iR,parametersR))
#labeling the columns
outLab <- c("year","detectedIncidence1","totalIncidence1","prevalence1","detectedIncidence2","totalIncidence2","prevalence2")
colnames(GMSoutiR) <- outLab
#grabbing the time of MDA success
#GMSoutiR[GMSoutiR[,3]<(1/12),1]
# MDAsuccessV1 <- GMSoutiR[,3]<(1/12)
# MDAsuccessV2 <- GMSoutiR[,6]<(1/12)
# successMDA <- cbind(MDAsuccessV1, MDAsuccessV2)
#calculating one year incidence per 1000 immediately after the end of MDA
MDAendsV1 <- which(timeVector==(2018+(tm_1+dm0)/12))
MDAendsV2 <- which(timeVector==(2018+(tm_2+dm1)/12))
DecOneYrIncV1 <- sum(GMSoutiR[MDAendsV1:(MDAendsV1+12),2])
TotOneYrIncV1 <- sum(GMSoutiR[MDAendsV1:(MDAendsV1+12),3])
DecOneYrIncV2 <- sum(GMSoutiR[MDAendsV2:(MDAendsV2+12),5])
TotOneYrIncV2 <- sum(GMSoutiR[MDAendsV2:(MDAendsV2+12),6])
OneYrInc <- cbind(DecOneYrIncV1, TotOneYrIncV1, DecOneYrIncV2, TotOneYrIncV2)
result[[((i-1)*81)+j]] <- OneYrInc  #successMDA
}
}
#time component #scenario
#outside of 'for' loop
#write.table(GMSoutiR[,1],'parameters/times.csv', col.names = 'time', row.names = FALSE)
#saveRDS(result, paste('results_homo_cov/results_loop_',loop,"_",gsub("\\:","",Sys.time()),'.rds',sep=''))
saveRDS(result, paste('results_covV12_bh_maxV2_homo/results_loop_',loop,"_",gsub("\\:","",Sys.time()),'.rds',sep=''))
#with seasonality on [switch is inside modGMS.cpp]
#Analysing the data list 'results_.rds'####
#see separate file for plotting
}
head(results)
head(result)
dim(result)
length(result)
length(result[[1]])
dim(testfor2)
#MDA_eff_homo_cov_forloop.R created only the RDS save files
#since one of the results doesn't have adequate rows
#each RDS file is read in and plotted individually
setwd("~/OneDrive/MORU/Projects/TCE_MDA effect/MDA_eff_hm/") #mac
library(deSolve)
library(shiny)
library(TSA)
library(Rcpp)
library(stringr)
#library(lattice)
library(ggplot2)
library(reshape)
sourceCpp("functions/modGMS.cpp")
source("functions/no longer app.R")
timeVector <- read.csv('parameters/times.csv')
homoLoop <- seq(0, by=10, to=100) # to=70)
#tmp2 <- NA
for(loop in 1:11){
result <- readRDS(paste("results_covV12_bh_maxV2_homo/results_loop_", loop,".rds", sep=""))
#testing####
#loop <- 1
#result <- readRDS("results_homo_cov_start0/results_loop_1_2019-03-22 141427.rds")
#result <- readRDS("results_homo_cov/results_2019-02-14 150440.rds")
#cmda_1 <- cmda_1Loop[loop]#80 #90
homogen <- homoLoop[loop]
#how soon is the outcome?
village1 <- sapply(result, function(x){
x[,2]<1
})
village2 <- sapply(result, function(x){
x[,4]<1
})
#putting into matrix
v1m <- matrix(as.numeric(village1),nrow=101,ncol=81, byrow=TRUE)
v2m <- matrix(as.numeric(village2),nrow=101,ncol=81, byrow=TRUE)
v12m <- matrix(as.numeric(village1),nrow=101,ncol=81, byrow=TRUE)+matrix(as.numeric(village2),nrow=101,ncol=81, byrow=TRUE)
toPlot <- melt(t(v12m))
#within one year period####
png(paste('results_covV12_bh_maxV2_homo/newPlot_OneYrInc/homogeniety_MDAcoverage_',homoLoop[loop],"_",gsub("\\:","",Sys.time()),'.png',sep=''),height= 1600, width=1800, units= "px", res=300)
print(
ggplot(data=toPlot, aes(x=X1, y=X2))+
geom_tile(aes(fill=factor(value)))+
ggtitle(paste0("No. of village with less than 1 case/1000 within 1 year after MDA\nHBR in village 1: 16; % of homogeniety: ",homogen))+
xlab("HBR in village 2")+ylab("% of MDA coverage in both villages")+
theme(legend.position = "bottom")+
scale_fill_manual(name="# of village", labels=c("zero", "one village", "two villages"),values=c("#999999", "#E69F00", "#56B4E9"))
)
dev.off()
}
#MDA_eff_homo_cov_forloop.R created only the RDS save files
#since one of the results doesn't have adequate rows
#each RDS file is read in and plotted individually
setwd("~/OneDrive/MORU/Projects/TCE_MDA effect/MDA_eff_hm/") #mac
library(deSolve)
library(shiny)
library(TSA)
library(Rcpp)
library(stringr)
#library(lattice)
library(ggplot2)
library(reshape)
sourceCpp("functions/modGMS.cpp")
source("functions/no longer app.R")
timeVector <- read.csv('parameters/times.csv')
homoLoop <- seq(0, by=10, to=100) # to=70)
#tmp2 <- NA
for(loop in 1:11){
result <- readRDS(paste("results_covV12_bh_maxV2_homo/results_loop_", loop,".rds", sep=""))
#testing####
#loop <- 1
#result <- readRDS("results_homo_cov_start0/results_loop_1_2019-03-22 141427.rds")
#result <- readRDS("results_homo_cov/results_2019-02-14 150440.rds")
#cmda_1 <- cmda_1Loop[loop]#80 #90
homogen <- homoLoop[loop]
#how soon is the outcome?
village1 <- sapply(result, function(x){
x[,2]<1
})
village2 <- sapply(result, function(x){
x[,4]<1
})
#putting into matrix
v1m <- matrix(as.numeric(village1),nrow=101,ncol=81, byrow=TRUE)
v2m <- matrix(as.numeric(village2),nrow=101,ncol=81, byrow=TRUE)
v12m <- matrix(as.numeric(village1),nrow=101,ncol=81, byrow=TRUE)+matrix(as.numeric(village2),nrow=101,ncol=81, byrow=TRUE)
toPlot <- melt(t(v12m))
#within one year period####
png(paste('results_covV12_bh_maxV2_homo/newPlot_OneYrInc/HBR_MDAcoverage_atHomogen_',homoLoop[loop],"_",gsub("\\:","",Sys.time()),'.png',sep=''),height= 1600, width=1800, units= "px", res=300)
print(
ggplot(data=toPlot, aes(x=X1, y=X2))+
geom_tile(aes(fill=factor(value)))+
ggtitle(paste0("No. of village with less than 1 case/1000 within 1 year after MDA\nHBR in village 1: 16; % of homogeniety: ",homogen))+
xlab("HBR in village 2")+ylab("% of MDA coverage in both villages")+
theme(legend.position = "bottom")+
scale_fill_manual(name="# of village", labels=c("zero", "one village", "two villages"),values=c("#999999", "#E69F00", "#56B4E9"))
)
dev.off()
}
max(toPlot)
dim(toPlot)
head(toPlot)
sum(is.na(toPlot$value))
toPlot[which(is.na(toPlot$value)),]
tail(result)
tail(testfor2)
