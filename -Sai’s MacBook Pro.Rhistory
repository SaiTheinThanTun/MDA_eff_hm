fypo(94.68,64.87)
fypo(325,261)
fypo(184,139.4)
420/12
1600/12
#for year payout
fypo <- function(currP, priorP, budget=5000){
(currP-priorP)*(budget/priorP)-budget
}
interest <- function(budget=5000,rate=.0825, years=1){
budget*rate*years
}
fypo(94,28) #MSFT 11758
fypo(1571, 257) #AMZN 25564
fypo(178, 65) #appl 3692
fypo(7481,3200) #nasdaq 1689
fypo(2750,1556) #nsp500 3836
60900*6
365400+250000
agesteps <- seq(17.5,by=5,length7)
agesteps <- seq(17.5,by=5,length=7)
agesteps
t5cohort <- c(80,150,140,120,70,30,10)
agesteps <- seq(17.5,by=5,length=7)
(t5cohort*agesteps)/sum(t5cohort)
sum(t5cohort*agesteps)/sum(t5cohort)
t10cohort <- c(40,100,150,130,100,60,20)
sum(t10cohort*agesteps)/sum(t10cohort)
(2.232-1)/2.232
(6-2.05)/6
(2.23-1)/2.23
244/45
771/4153
4153/5*16993
5*4153/16993
(5*4153/16993)*1000
(4153/16993)*1000/5
244/5
48.8-45.1
771*5
4153/5
1587/(5*22715.83)
1587/(5*23577)
778/(5*11858)=
778/(5*11858)
getwd()
dat <- read.csv('assessment_data.csv')
dat
dim(dat)
names(dat)
summary(dat$stunted)
summary(dat$underweight)
2445-2383
342+829+416+381+1245
1738-1362
1738.54-1362.97
4473-4350
4751-4621
130/4751
7110-6921
583/60
.42*15
3000/14
200*14
5400-2400
583.91-352.1
.018*10000
.018*1000
.018*1500
.42*15
15/.42
150000+500000
650000*12
70*14
331/2
2383.86+10.74
2383.86+10.74-15.6
17000/12
4000*12
60000/12
1400*.3
130-116
1060-1036
1350*7700
1350*77000
17000/12
70*14
(7146/57486)-(4264/41756)
.07146-.04264
.02881
4300/12
2800*12
755500/12
17500+960+3250
300*1000
mean(61,53,55,62,50,54,55,52,54,54,55,65,51,70,59,73,72,66,73,78)
2800*12
7150/6919.68
7190/6919.68
6919.68/7190
(7190-6919.68)/6919.68
.08/12
6900*.00666667
75+348+450+1500
350+83
433*12
4300/12
4300/12
5100/12
2000*1.1
.47/3.15
.42*15
7220-6920
1817/207
1817/204
1817/203
1817/202
1817/201
15*300
6920*(.08/12)
60900*4
243600+140000
1.1/200
(.0055*4)
(.42/94)*4
207*15
(207*15)*.022
.022*7000
15*4.4
15*207
0.022/12
(0.022/12)*10000
(0.022/12)*15
(0.022/12)*3100
1.1*15/3
(0.022/12)*20000
(0.022/4)*20000
.022*3100
.022*3100*5
.21/60
(.21/60)*4
.21*6
.21*15
.015*10000
100/924.8
2/33.5
9000+3747
.01*2000
2000/100
3700+9000
12700*12
40000/12
30000/12
2800*12
1400*18
(33600+25200)/36
47000/12
24000/122
24000/12
1000/22
7.84*16
125*4
16/7
16/5
16/3
3750+9000
1800/40
80*90
18*90
7700/1300
20000/12
3000/12
75*16
204406/554040
204406/(330117+125711)
(86/100)*5
(4.3+3)/10
(4.3+3)/5
(4.3+3)/2
1800*12
110*30
1986+8
2003-10
1993+8
100-35
ln
log
?log
log(2)/(1.08)
log(2)/(1+(8/12))
log(2)/(1+(.08/12))
log2
log(2)
log(2)/(.08)
89934033+2813900
89934033+28139000
60900-25000
.08/12
21*120
21*88
67+36
54000-(17000*2)
116900*.5
116900*.05
5000/156
36*1.1
40*1.1
15000/30
f <- function(x){
x^3-3*x^2-3*x-4
}
f(0)
f(3)
f(2.5)
f(-2.5)
f(1)
f(.1)
f(-.1)
plot(f(seq(from=-5,to=5,by=.001)))
plot(seq(from=-5,to=5,by=.001),f(seq(from=-5,to=5,by=.001)))
# f <- function(x){
#   x^3-3*x^2-3*x-4
# }
f <- function(x){
x^3-x^2+3*x+7
}
f(0)
f(2.5)
f(-2.5)
f(1)
f(.1)
f(-.1)
plot(seq(from=-5,to=5,by=.001),f(seq(from=-5,to=5,by=.001)))
# f <- function(x){
#   x^3-3*x^2-3*x-4
# }
# f <- function(x){
#   x^3-x^2+3*x+7
# }
f <- function(x){
x^3-7*x^2-3*x+3
}
f(0)
f(2.5)
f(-2.5)
f(1)
f(.1)
f(-.1)
plot(seq(from=-5,to=5,by=.001),f(seq(from=-5,to=5,by=.001)))
60000-25000
factorial(7)
7*6*5*4*3*2
factorial(5)
factorial(6)
factorial(8)
?desolve
?ode
library(desolve)
library(dsolve)
install.packages("desolve")
library(deSolve)
install.packages("deSolve")
library(deSolve)
?ode
12000/12
results
result <- readRDS("results_homo_cov_start0/results_loop_1_2019-03-22 141427.rds")
setwd("~/OneDrive/MORU/Projects/TCE_MDA effect/MDA_eff_hm/") #mac
setwd("~/OneDrive/MORU/Projects/TCE_MDA effect/MDA_eff_hm/") #mac
result <- readRDS("results_homo_cov_start0/results_loop_1_2019-03-22 141427.rds")
library(deSolve)
library(shiny)
library(TSA)
library(Rcpp)
library(stringr)
#library(lattice)
library(ggplot2)
library(reshape)
result <- readRDS("results_homo_cov_start0/results_loop_1_2019-03-22 141427.rds")
sourceCpp("functions/modGMS.cpp")
source("functions/no longer app.R")
result <- readRDS("results_homo_cov_start0/results_loop_1.rds")
head(result)
#for loop for changing MDA coverage in the first village
#MDA_eff_hm
#MDA success on homogeniety vs coverage
#20180124
#see #scenario tag for things to change in each scenario
#x axis variable: homogen, [0 to 100] %
#y axis variable: cmda_2, [0 to 80] %, coverage of MDA in second village
setwd("~/OneDrive/MORU/Projects/TCE_MDA effect/MDA_eff_hm/") #mac
library(deSolve)
library(shiny)
library(TSA)
library(Rcpp)
library(stringr)
library(lattice)
sourceCpp("functions/modGMS_seas.cpp")
source("functions/no longer app.R")
timeVector <- read.csv('parameters/times.csv') #to figure out when the MDA finishes
#scenario
##initialize input and output storage####
testfor2j <- rep(0:100,81)
testfor2i <- rep(0:80,each=101)
testfor2 <- cbind(testfor2j,testfor2i)
# colnames(testfor2) <- c('homogen','cmda_2')
colnames(testfor2) <- NULL
#successwithin <- 6
successwithin <- 12 #months
#scenario
####for template####
# for(i in 1:81){
#   for(j in 1:101){
#     homogen <- testfor2[((i-1)*101)+j,1]
#     cmda_2 <- testfor2[((i-1)*101)+j,2]
#     ###other codes for running the model
#     result[[((i-1)*101)+j]] <- successMDA
#   }
# }
####non-reactive parameters####
####interventions####
EDATon = TRUE
ITNon = TRUE
IRSon = FALSE
MDAon = TRUE
primon = TRUE #FALSE
MSATon = TRUE
VACon = FALSE
####non-reactive functions####
#got from the "parameters" folder #scenario
cmda_1Loop <- seq(0, by=10, to=90)
for(loop in 1:length(cmda_1Loop)){
result <- list()
API <- 2.5
eta <- 30
covEDAT0 <- 25
covITN0 <- 70
effITN <- 30
covIRS0 <- 0
effIRS <- 15
muC <- 1
muA <- 1
muU <- 1
percfail2018 <- 5
percfail2019 <- 15
percfail2020 <- 30
bh_max0 <- 16
bh_max1 <- 16
rhoa <- 55
rhou <- 17
EDATscale <- 1
covEDATi <- 70
ITNscale <- 1
covITNi <- 90
IRSscale <- 1
covIRSi <- 90
lossd <- 30
dm0 <- 3
dm1 <- 3
cmda_1 <- cmda_1Loop[loop]#80 #90
#cmda_2 <- 50 #scenario
#homogen <- 0 #scenario
tm_1 <- 9
tm_2 <- 9
p1v <- 0.5
effv_1 <- 75
effv_2 <- 80
vh <- 90
MSATscale <- 1
covMSATi <- 90
MSATsensC <- 99
MSATsensA <- 87
MSATsensU <- 44
#non-reactive parameters
# define the number of weeks to run the model
dt<-1/12
startyear<-2007
stopyear<-2023
maxt<-stopyear-startyear
times <- seq(0, maxt, by = dt)
tsteps<-length(times)
# initial prevalence
initprevR <- (0.001*API)
#ParLabel <- read.table('functions/ParLabel.csv', sep=",", as.is=TRUE)
# scenario_0<-c(EDATon = 0,
#               ITNon = 0,
#               IRSon = 0,
#               MDAon = 0,
#               primon = 0,
#               MSATon = 0,
#               VACon = 0)
####for loop#####
for(i in 1:81){
for(j in 1:101){
homogen <- testfor2[((i-1)*101)+j,1]
cmda_2 <- testfor2[((i-1)*101)+j,2]
###other codes for running the model
scenario_iR<-(c(EDATon = EDATon,
ITNon = ITNon,
IRSon = IRSon,
MDAon = MDAon,
primon = primon,
MSATon = MSATon,
VACon = as.numeric(VACon)))
parametersR <- (c(
bh_max0 = bh_max0,                 # bites per human per night
bh_max1 = bh_max1,
eta = eta,
covEDAT0 = covEDAT0,
covITN0 = covITN0,
effITN = effITN,
covIRS0 = covIRS0,
effIRS = effIRS,
muC = muC,
muA = muA,
muU = muU,
percfail2018 = percfail2018,
percfail2019 = percfail2019,
percfail2020 = percfail2020,
EDATscale = EDATscale,
covEDATi = covEDATi,
ITNscale = ITNscale,
covITNi = covITNi,
IRSscale = IRSscale,
covIRSi = covIRSi,
cmda_1 = cmda_1,
cmda_2 = cmda_2,
tm_1 = tm_1,          # timing of 1st round [2018 to 2021 - 1 month steps]
tm_2 = tm_2,          # timing of 2nd round [2018+(1/12) to 2021 - 1 month steps]
dm0 = dm0,
dm1 = dm1,
lossd = lossd,
MSATscale = MSATscale,
covMSATi = covMSATi,
MSATsensC = MSATsensC,
MSATsensA = MSATsensA,
MSATsensU = MSATsensU,
effv_1 = effv_1,
effv_2 = effv_2,
vh = vh,
homogen = homogen,
p1v = p1v,
rhoa=rhoa,
rhou=rhou
))
#GMSout0R <- (runGMS(initprevR, scenario_0,parametersR))
GMSoutiR <- (runGMS(initprevR, scenario_iR,parametersR))
#labeling the columns
outLab <- c("year","detectedIncidence1","totalIncidence1","prevalence1","detectedIncidence2","totalIncidence2","prevalence2")
colnames(GMSoutiR) <- outLab
#grabbing the time of MDA success
#GMSoutiR[GMSoutiR[,3]<(1/12),1]
# MDAsuccessV1 <- GMSoutiR[,3]<(1/12)
# MDAsuccessV2 <- GMSoutiR[,6]<(1/12)
# successMDA <- cbind(MDAsuccessV1, MDAsuccessV2)
#calculating one year incidence per 1000 immediately after the end of MDA
MDAendsV1 <- which(timeVector==(2018+(tm_1+dm0)/12))
MDAendsV2 <- which(timeVector==(2018+(tm_2+dm1)/12))
DecOneYrIncV1 <- sum(GMSoutiR[MDAendsV1:(MDAendsV1+12),2])
TotOneYrIncV1 <- sum(GMSoutiR[MDAendsV1:(MDAendsV1+12),3])
DecOneYrIncV2 <- sum(GMSoutiR[MDAendsV2:(MDAendsV2+12),5])
TotOneYrIncV2 <- sum(GMSoutiR[MDAendsV2:(MDAendsV2+12),6])
OneYrInc <- cbind(DecOneYrIncV1, TotOneYrIncV1, DecOneYrIncV2, TotOneYrIncV2)
result[[((i-1)*101)+j]] <- OneYrInc  #successMDA
}
}
#time component #scenario
#outside of 'for' loop
#write.table(GMSoutiR[,1],'parameters/times.csv', col.names = 'time', row.names = FALSE)
#saveRDS(result, paste('results_homo_cov/results_loop_',loop,"_",gsub("\\:","",Sys.time()),'.rds',sep=''))
saveRDS(result, paste('results_homo_cov_start0_seas/results_loop_',loop,"_",gsub("\\:","",Sys.time()),'.rds',sep=''))
#with seasonality on [switch is inside modGMS.cpp]
#saveRDS(result, paste('results_homo_cov_start0_seas/results_loop_',loop,"_",gsub("\\:","",Sys.time()),'.rds',sep=''))
#scenario
#Analysing the data list 'results_.rds'####
#readRDS
#
# timeVector <- read.csv('parameters/times.csv')
# MDAstart <- which(timeVector==(2018+tm_1/12))
#
# #draft
# #result[[1]][MDAstart:(MDAstart+successwithin),]
# #sum(result[[1]][MDAstart:(MDAstart+successwithin),1])>0
#
# village1 <- sapply(result, function(x){
#   sum(x[MDAstart:(MDAstart+successwithin),1])>0
# })
# village2 <- sapply(result, function(x){
#   sum(x[MDAstart:(MDAstart+successwithin),2])>0
# })
#
# #putting into matrix
# v1m <- matrix(as.numeric(village1),nrow=80,ncol=100, byrow=TRUE)
# #heatmap(v1m, Rowv=NA, Colv = NA)
# #v1md <- as.data.frame(as.numeric(village1),nrow=80,ncol=100, byrow=TRUE)
# levelplot(t(v1m))
#
# v2m <- matrix(as.numeric(village2),nrow=80,ncol=100, byrow=TRUE)
# #heatmap(v2m, Rowv=NA, Colv = NA)
# levelplot(t(v2m))
#
# v12m <- matrix(as.numeric(village1),nrow=80,ncol=100, byrow=TRUE)+matrix(as.numeric(village2),nrow=80,ncol=100, byrow=TRUE)
# #heatmap(v12m, Rowv=NA, Colv = NA, col=heat.colors(3))
# #write.csv(v12m,'results_homo_cov/v12m.csv')
#
# new.palette=colorRampPalette(c("red","black"),space="rgb")
# levelplot(t(v12m), col.regions=new.palette, xlab="% of homogeniety", ylab="% of MDA coverage in village 2", main="No. of villages reaching below elimination threshold")
#
# png(paste('results_homo_cov/homogeniety_MDAcoverage',gsub("\\:","",Sys.time()),'.png',sep=''),height= 1600, width=1800, units= "px", res=300)
# levelplot(t(v12m), col.regions=new.palette, xlab="% of homogeniety", ylab="% of MDA coverage in village 2", main=paste("No. of villages reaching below elimination threshold \n MDA coverage in village 1", cmda_1))
# dev.off()
}
